[["index.html", "An Introduction to R About this tutorial", " An Introduction to R Jeremy Oakley 2022-09-15 About this tutorial This tutorial is written for students on MAS109 and MAS5052. Part I covers the basics of working with R, and will be needed throughout both modules. Part II gives an illustration of using R to do simulation (the “Monte Carlo” method). You will not be required to implement simulation yourself on either module, but some simulation ideas are used in later lectures on hypothesis testing; this illustration will help with those. Part III gives a short introduction to R Markdown - this will be needed for practical assignments. Part IV has some extra topics that are all optional for both modules, but you may find these helpful. "],["r-and-rstudio.html", "Section 1 R and RStudio 1.1 Using R on campus 1.2 Using R at home 1.3 The RStudio interface 1.4 Inputs and outputs 1.5 Get comfortable! 1.6 Change your Workspace settings", " Section 1 R and RStudio The programming language that we are using is called R (R Core Team 2020), but we will use a separate program, called RStudio (RStudio Team 2020), known as an “Integrated Development Environment”, to work with R. You can use R without using RStudio, but you can’t use RStudio without using R. 1.1 Using R on campus If you are using a computer on the university network, click on the Windows 10 icon in the bottom left corner of the screen, then search the list of programs and click on RStudio. 1.2 Using R at home You can download both RStudio and R for free on your own computer. Download R Download RStudio 1.3 The RStudio interface When you first start RStudio, you should see something like this: There are three windows (a fourth will appear later), and for now, we’ll just use the one on the left, which is called the Console. The red circle drawn in the console window shows the command prompt: this is where you type in commands. 1.4 Inputs and outputs In these notes, input will be displayed in shaded boxes like this: 2 + 3 and output from R will be shown like this: ## [1] 5 (Ignore the ## symbols and the [1] for now: the output we want is the number 5: the result of the command 2 + 3.) You can copy and paste input directly from these pages into RStudio (it’s helpful to know the keyboard shortcuts for copy and paste: these are usually ctrl c and ctrl v on windows PCs, and cmd c and cmd v on macs.) You should try the commands you see here directly in RStudio, to check that they work and that you get the same results. 1.5 Get comfortable! You will be using RStudio quite a lot, so you may wish to change the appearance. Some people find dark backgrounds more comfortable for reading. From the menu bar, go to Tools &gt; Global Options Click on Appearance Change the Editor font size if you want to Try out a few themes in the Editor theme box. (The default is Textmate. I prefer Pastel on Dark). Once you find something you like (or just stick with Textmate if you are happy with the default appearance), click on OK, and continue with this tutorial. 1.6 Change your Workspace settings R has an optional setting, in which any variables and functions that you have defined are saved and reloaded each time you quit and restart. I suggest you don’t use this setting. To make sure it is switched off, go to Tools &gt; Global Options… Make sure the box Restore .RData into workspace on startup is not ticked; Set Save workspace to .RData on exit to Never The settings should look like this: References "],["using-r-as-a-calculator.html", "Section 2 Using R as a calculator 2.1 Scientific notation 2.2 Order of operations", " Section 2 Using R as a calculator To do addition, subtraction, multiplication and division, use the symbols +, -, *, / respectively. For example, if you type 5 * 6 at the command prompt, and press return, you will see 5 * 6 ## [1] 30 The symbol ^ is used for raising a number to a power. For example, to calculate \\(2^4\\), try the following 2 ^ 4 ## [1] 16 2.1 Scientific notation Large numbers may be displayed using “scientific notation”. For example, if we calculate \\(500^3\\) in R, instead of displaying 125000000 as the result, we see 500 ^ 3 ## [1] 1.25e+08 When you see e appear within a number, read it as “multiplied by 10 to the power of”. So 1.25e+08 is read as “1.25 multiplied by 10 to the power of 8”. Exercise 2.1 Replace x with a suitable number in the following command 1 / 1000 ^ x to produce the output ## [1] 1e-09 Check your answer by trying the calculation in R. 2.2 Order of operations R will follow the BODMAS (Brackets, Orders (powers/roots), Division, Multiplication, Addition, Subtraction) rule for the order in which it will carry out calculations. Exercise 2.2 First, predict what result you would get from each of these commands. Then try them in R. 4 / 2*2 4 / (2*2) 16 ^ 1/2 16 ^ (1/2) "],["variables-and-vectors.html", "Section 3 Variables and vectors 3.1 Vectors 3.2 Testing for equality and inequalties 3.3 Subsetting vectors 3.4 Character strings 3.5 Factors 3.6 The Environment window", " Section 3 Variables and vectors We can assign a numerical value to what we refer to as a variable, and then use the variable within various R commands. For example x &lt;- 3 defines a variable called x, which takes the value 3. You won’t see any output when you type this command, but if you type the variable name on its own, R will tell you its value: x ## [1] 3 We can then use the variable in other commands, e.g.: 2 * x ## [1] 6 Everything in R is case sensitive: x is not the same as X. 3.1 Vectors We can define a vector variable using the command c(), with a list of the elements in your vector, separated by commas, inside the brackets. For example, to create a vector of the numbers 2, 4, 6, 8, 10, and assign it to a variable y type y &lt;- c(2, 4, 6, 8, 10) We can do element-wise operations with two vectors. For example: z &lt;- c(3, 5, 7, 9, 11) y + z ## [1] 5 9 13 17 21 3.1.1 Sequences of integers A convenient way to create a sequence of integers (as a vector) is to use :, for example 3:10 ## [1] 3 4 5 6 7 8 9 10 and we can assign the result to a vector variable in the usual way. x &lt;- 3:10 3.2 Testing for equality and inequalties Given a vector such as x ## [1] 3 4 5 6 7 8 9 10 we can test to see if elements of this vector equal a particular value, e.g. x == 4 ## [1] FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE which produces another vector, where the i-th element is TRUE if the i-th element of x is equal to 4, and FALSE otherwise. Similarly, we can test for an inequality, for example x &lt; 5 ## [1] TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE If we sum the result, each TRUE is counted as a 1, and each FALSE is counted as a 0, so we can find out how many elements of x satisfy the inequality (or equality): sum(x &lt; 5) ## [1] 2 3.3 Subsetting vectors Suppose we have first defined a vector x: x &lt;- c(12, 14, 16, 18, 20) We use square brackets [] to extract elements of x. For example, to get the third element we do x[3] ## [1] 16 Exercise 3.1 If x has been defined as x &lt;- c(12, 14, 16, 18, 20) predict which elements of x would be returned with the following, then try these commands in R: x[2:4] x[c(1, 3, 5)] x[-4] We can also replace elements of x, for example x[2] &lt;- 0 x ## [1] 12 0 16 18 20 3.3.1 Logical subsetting Given our definition of x, if we first do x &lt;- c(12, 14, 16, 18, 20) x &lt; 15 ## [1] TRUE TRUE FALSE FALSE FALSE We see that TRUE is returned in position i, if the i-th element of x is less than 15. We can use this to extract the elements of x that satisfy the condition of being less than 15: x[x &lt; 15] ## [1] 12 14 3.4 Character strings We can make vectors whose elements are text (known as strings or character strings) rather than numbers. x &lt;- c(&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;) x ## [1] &quot;Monday&quot; &quot;Tuesday&quot; &quot;Wednesday&quot; The quote marks \" \" are important here: if, for examle, we tried y &lt;- Monday We would get the message Error: object 'Monday' not found: R would attempt to find a variable with the name Monday, rather than assigning the string \"Monday\" to the variable y. 3.5 Factors In statistical modelling, we often work with categorical variables, for example, a patient’s symptoms might be recorded as one of “none”, “mild”, “moderate”, or “severe”. In R, we can have factor variables that are similar to strings, but which carry additional information about the possible levels. We create these with the factor() command. For example x &lt;- factor(c(&quot;mild&quot; ,&quot;mild&quot;, &quot;none&quot;, &quot;severe&quot;)) x ## [1] mild mild none severe ## Levels: mild none severe Note that when we display our vector of factors x, we do not see quotes, and the levels are also displayed. When defining a factor, it may be helpful to specify all the possible levels, even if some levels have not been observed. We specify these in the factor command: x &lt;- factor(c(&quot;mild&quot; ,&quot;mild&quot;, &quot;none&quot;, &quot;severe&quot;), levels = c(&quot;none&quot;, &quot;mild&quot; ,&quot;moderate&quot;, &quot;severe&quot;)) x ## [1] mild mild none severe ## Levels: none mild moderate severe (Note that the first two lines in the input display are a single command: the line break after the first comma is ignored by R.) 3.6 The Environment window In RStudio, you can see all the variables defined in your workspace in the Environment window. The Environment window will also list any data sets and functions that you have created; you can click on these for more details. Exercise 3.2 Suppose we want to create a vector called responses with three elements: yes, no and no. Create the vector responses as a vector of character strings. How would you define responses, if you instead wanted it to be a factor, with levels yes, no and undecided? "],["functions.html", "Section 4 Functions 4.1 Introducing functions 4.2 Arguments 4.3 Help files", " Section 4 Functions 4.1 Introducing functions (We’ve been using some functions already, but we’ll now discuss these explicitly). R has lots of functions we can use for doing various things (and you can even create your own). For example, the function mean() will calculate the arithmetic mean of the elements of a vector: x &lt;- 1:10 mean(x) ## [1] 5.5 4.2 Arguments Functions typically have various arguments that we can either specify, or leave unspecified, in which case they will take default values. For example, if we do y &lt;- c(5, 10, 6, 11, 7, 12) sort(y) ## [1] 5 6 7 10 11 12 then we can see that sort(y) has sorted the elements of y into increasing order. To sort them into decreasing order, we add an argument decreasing = TRUE: sort(y, decreasing = TRUE) ## [1] 12 11 10 7 6 5 4.2.1 Experiment! It’s a good idea to experiment with function arguments, to understand how a function works. For example, try this command seq(from = 0, to = 10, length = 11) ## [1] 0 1 2 3 4 5 6 7 8 9 10 then experiment with changing the numbers for the three arguments from, to and length. Try to predict what the effect of any change will be, before running the command. 4.3 Help files All functions have help files, which tell you a bit more about how the function works, and often provide examples. Use a ? with the function name: ?sort Help files can be a little overwhelming! If you scroll to the end of a help file, there are usually some examples you can try: trying the examples can often help you to understand how a function works. Exercise 4.1 Rolling dice. Suppose a 6-sided dice is rolled once. Try the command sample(1:6, size = 1) to get R to simulate the dice roll. Use the up arrow key on your keyboard to bring up the command again, and press return. Do this a few times to check that you get different results each time. Now suppose the 6-sided dice is rolled six times. Try changing the size argument to 6: sample(1:6, size = 6) Run the command above a few times (again, use the up arrow on your keyboard, so you don’t have to keep typing it.) Something about the results you get should look odd. Look at the help file for sample, and see what that default arguments are. What do you need to change, to get more realistic behaviour when simulating 6 dice rolls? "],["packages.html", "Section 5 Packages 5.1 Installing a package 5.2 Updating packages 5.3 Using packages 5.4 Is there a package for…?", " Section 5 Packages R has a large number of packages available (over 16,000 at the time of writing). R packages typically contain extra functions based around some theme (e.g. a collection of functions to enable you to fit a particular type of statistical model.) Some packages come pre-installed with R, and others need to be installed manually. 5.1 Installing a package Use the command install.packages() to install a package. If the package you want requires other packages, R will install them too, so installation can take a while! During the installation process, you may get a message along the lines of ...There are binary versions available but the source versions are later. Do you want to install from sources the package which needs compilation? Answering n (for no) is usually safe, in case your computer isn’t set up for installing packages ‘from source’. As an example, we’ll install the zoo package, which has some helpful functions for working with time series data. install.packages(&quot;zoo&quot;) Only type an install.packages() command in the console window. Do not use this command in a script or R Markdown document (we will study scripts and R Markdown shortly). This will avoid you repeatedly installing the same package. 5.2 Updating packages It’s worth occasionally checking for package updates. In particular, if a package you’re using doesn’t appear to be working properly, look to see if there’s an update. In RStudio, click on the Packages tab, and then click on Update to see what’s available. 5.3 Using packages A package only needs to be installed once, but you need to load the package every time you start R, or use the :: syntax. For example, the zoo package has a function rollmean() for computing rolling means (e.g. mean at time \\(t\\) of the most recent 4 observations up to time \\(t\\)). As an example, suppose we have a vector x: x &lt;- 10:20 We can either use the syntax package-name::function. zoo::rollmean(x, k = 4) ## [1] 11.5 12.5 13.5 14.5 15.5 16.5 17.5 18.5 or we can first do library(zoo) ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric and then any function within the package can be used directly: rollmean(x, k = 4) ## [1] 11.5 12.5 13.5 14.5 15.5 16.5 17.5 18.5 For some packages (e.g. ggplot2), it will be obvious from the commands what package is being used. Otherwise, I recommend you use the :: syntax as it will make your code easier to read; it can be helpful to be explicit about which package a function has come from. 5.4 Is there a package for…? You shouldn’t need to search for packages in this module, but you might wish to find a package to do something on another module. If you’re searching for a package to do something, one simple approach is to include “R CRAN” in your web search, e.g. you might search for R CRAN lasso if you were looking for a package to implement a statistical technique called the “lasso”. (CRAN is the main repository for R packages). You could also try browsing the CRAN Task Views. These discuss some of the packages that are available for particular topics (e.g Bayesian inference, machine learning, time series analysis etc.) "],["data-frames-tibbles-and-lists.html", "Section 6 Data frames, tibbles and lists 6.1 Data frames 6.2 tibbles 6.3 Inspecting large data frames and tibbles 6.4 Lists", " Section 6 Data frames, tibbles and lists 6.1 Data frames Data sets in R are organised in data frames. R has various built-in data frames that we can use as illustrations, for example, mtcars. The full data set has 32 rows, but we will just display the first 6, using the head() function head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 Each column has a name (mpg, cyl, etc.) which can be used to access the values in that column. The rows in this data frame are also named, but that is optional, and we usually select particular rows by their row number. The mtcars data frame has columns of numeric quantities only (though some columns are really dummy variables to represent factors), but is common for data frames to have a mix of variable types, for example, in the CO2 data frame we have head(CO2) ## Plant Type Treatment conc uptake ## 1 Qn1 Quebec nonchilled 95 16.0 ## 2 Qn1 Quebec nonchilled 175 30.4 ## 3 Qn1 Quebec nonchilled 250 34.8 ## 4 Qn1 Quebec nonchilled 350 37.2 ## 5 Qn1 Quebec nonchilled 500 35.3 ## 6 Qn1 Quebec nonchilled 675 39.2 The built-in data frames have help files with more information: try ?mtcars for example. Built-in data frames are useful when giving examples, or asking for help online: everyone will have them, so code using a built-in frame can be easy for others to run. 6.1.1 Making data frames A data frame can be made within R using the function data.frame(), but more commonly, we’ll be making data frames by importing data into R (e.g. .csv files). We’ll cover this later on. 6.1.2 Extracting rows and columns Extracting data from data frames can be confusing, in that there are multiple ways to do it, and the format of the result (e.g. a vector or another data frame) can vary. For now, one syntax for extracting a column is dataframe-name$column-name, for example: mtcars$cyl ## [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4 and a complete row can be extracted using its position (row number): mtcars[2, ] ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4 We’ll look more at extracting subsets of data frames later on. 6.2 tibbles A tibble is a special type of data frame (Müller and Wickham 2020). When we view a tibble, R will normally only show the first 10 rows, and as many columns as can be fitted in the screen (but R will tell us if there are more columns). For example, a tibble version of the mtcars data frame would look like this (you will need to install the tibble package for this command to work): ## # A tibble: 32 × 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows Line three tells us what data type we have in each column. (&lt;dbl&gt; is short for “double precision”, a numeric variable type). In this module, it won’t make any difference whether our data are in a tibble format or ‘standard’ data frame, but there are some situations where they behave differently. If we want to force R to display all the rows of a tibble, we can use the print function: mtcarsTibble &lt;- tibble::tibble(mtcars) print(mtcarsTibble, n = nrow(mtcarsTibble)) 6.3 Inspecting large data frames and tibbles If we have a large number of columns in a data frame or tibble in R, it can be difficult to see exactly what data we’ve got. (The default display of a large tibble can still be overwhelming.) The str() function can be useful here (and will work with any type of R object): str(mtcars) ## &#39;data.frame&#39;: 32 obs. of 11 variables: ## $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: num 160 160 108 258 360 ... ## $ hp : num 110 110 93 110 175 105 245 62 95 123 ... ## $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## $ wt : num 2.62 2.88 2.32 3.21 3.44 ... ## $ qsec: num 16.5 17 18.6 19.4 17 ... ## $ vs : num 0 0 1 1 0 1 0 1 1 1 ... ## $ am : num 1 1 1 0 0 0 0 0 0 0 ... ## $ gear: num 4 4 4 3 3 3 3 4 4 4 ... ## $ carb: num 4 4 1 1 2 1 4 2 2 4 ... A similar function, with slightly different output, is tibble::glimpse(mtcars) ## Rows: 32 ## Columns: 11 ## $ mpg &lt;dbl&gt; 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, 17.8,… ## $ cyl &lt;dbl&gt; 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 8,… ## $ disp &lt;dbl&gt; 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7, 140.8, 16… ## $ hp &lt;dbl&gt; 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 180, 180, 180… ## $ drat &lt;dbl&gt; 3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92,… ## $ wt &lt;dbl&gt; 2.620, 2.875, 2.320, 3.215, 3.440, 3.460, 3.570, 3.190, 3.150, 3.… ## $ qsec &lt;dbl&gt; 16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20.00, 22.90, 18… ## $ vs &lt;dbl&gt; 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,… ## $ am &lt;dbl&gt; 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,… ## $ gear &lt;dbl&gt; 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3,… ## $ carb &lt;dbl&gt; 4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2,… 6.4 Lists We’ll briefly mention another type of object known as a list. Whereas a data frame is essentially a table, combining columns of the same length, a list is a more general collection of objects, which can vary in size and type. For example, we can create a list as follows: mylist &lt;- list(a = 1:10, b = &quot;Monday&quot;) We can view the names of the objects inside a list with the command names(mylist) ## [1] &quot;a&quot; &quot;b&quot; and access objects inside the list with the $ operator: mylist$b ## [1] &quot;Monday&quot; A data frame behaves like a list: it is a list of columns (although there are extra things you can do with data frames that you can’t do with lists.) Exercise 6.1 The data frame morley contains data from experiments measuring the speed of light. Find the mean recorded speed of light, for all 100 observations. References "],["scripts.html", "Section 7 Scripts 7.1 Creating a new script 7.2 Entering and running commands 7.3 Adding comments and sections in scripts 7.4 Line breaks in scripts 7.5 Saving a script", " Section 7 Scripts We’re reaching the point of wanting to use multiple commands in one go, and typing commands directly into the command prompt won’t be very convenient: it will be difficult to save your work it’s awkward if you make any mistakes A more convenient way to work with R is to use scripts. A script file is a list of commands, that is easier to edit, save, and run. 7.1 Creating a new script You can either select File &gt; New File &gt; R Script from the menu bar, or you can click on the icon in the top left corner and select R script. A new blank window will appear: this is your script window, where you can now enter commands. 7.2 Entering and running commands You can type R commands in to your script window, as you did in the console, but when you press return, nothing will happen. To get R to run a single line, click on that line so that the cursor is on that line, then click on Run at the top of the script window. To get R to run multiple lines at once, highlight all the lines with the mouse, then click on Run. To see what value a particular variable is, after you have run the line in which the variable is defined, highlight the variable name only, and then click on Run. Output will appear in the Console window, as before. 7.3 Adding comments and sections in scripts Use the # symbol to start a ‘comment line’: any text on that line will be ignored by R. Adding comments to your script can make it a little easier to read. You can also make a ‘section’ by adding four minus signs after your comment. These sections can be ‘collapsed’ and expanded again in RStudio, by clicking on the little arrow next to the line number. From now on, put all your solutions to the exercises in a script, and start each section with a comment giving the exercise number 7.4 Line breaks in scripts If we use a function with several arguments, and some of the arguments are quite long, it may be easier to read if we use a new line for each argument. The previous line must end with a comma , and then R will understand that the function continues on to the next line. For example, sample(1:6, size = 6, replace = TRUE) can be written as sample(1:6, size = 6, replace = TRUE) 7.5 Saving a script Go to File &gt; Save As.. to save your script. ::: {.exercise} Working with scripts. First, outside of RStudio, create a new folder with this module code on your computer (use your U: drive if you are on the university network). Create a new script file Copy and paste these commands into the script x &lt;- sample(2 * 1:10, size = 1) y &lt;- sample(2 * 1:10, size = 1) x * y Run these three commands in the script window. Without typing any more commands into the script or console windows, find out the values of x and y (highlight something appropriate and click on the run button.) Save your script in your folder. ::: "],["a-tip-for-understanding-r-code.html", "Section 8 A tip for understanding R code", " Section 8 A tip for understanding R code When you see a section of R code, it may not be obvious what the code does (although you can sometimes guess from the function names). As an example, consider x &lt;- rep(2:4, each = 3) sum(unique(x)) ## [1] 9 How did R get the result 9? It can sometimes help to run sections of the code, to see what each bit does: you can then see the individual steps that get to the result. In particular, you might run sections within a single line. We first see what the variable x is: x ## [1] 2 2 2 3 3 3 4 4 4 We can see that the numbers 2, 3, 4 have been repeated (using rep()) three times each. Then we can see what unique(x) does unique(x) ## [1] 2 3 4 This gets rid of the duplicates in the vector x. So we can see that the last line is working out the sum of 2, 3, 4. "],["monte-carlo-methods.html", "Section 9 Monte Carlo methods 9.1 The origins of Monte Carlo 9.2 The birthday problem", " Section 9 Monte Carlo methods We will now give an illustration of using R to solve some problems in probability using simulation (“Monte Carlo” methods). We will introduce one programming concept to help with this: the for loop1. 9.1 The origins of Monte Carlo Canfield Solitaire is a card game where you have to arrange all 52 cards into four ‘foundation’ piles, one for each suit, with the cards in increasing order, following rules about when to turn over cards and when to move cards between the various piles. (You don’t actually need to know the rules for this tutorial, and they are quite hard to understand until you’ve seen someone play the game!) Could you work out the probability of winning the game? Working this out analytically would be incredibly hard, but there is another way: the Monte Carlo method, invented by the Polish mathematician and physicist Stanislaw Ulam (1909-1984). He wrote2: “The first thoughts and attempts I made to practice [the Monte Carlo Method] were suggested by a question which occurred to me in 1946 as I was convalescing from an illness and playing solitaires. The question was what are the chances that a Canfield solitaire laid out with 52 cards will come out successfully? After spending a lot of time trying to estimate them by pure combinatorial calculations, I wondered whether a more practical method than”abstract thinking” might not be to lay it out say one hundred times and simply observe and count the number of successful plays. This was already possible to envisage with the beginning of the new era of fast computers, and I immediately thought of problems of neutron diffusion and other questions of mathematical physics, and more generally how to change processes described by certain differential equations into an equivalent form interpretable as a succession of random operations. Later [in 1946], I described the idea to John von Neumann, and we began to plan actual calculations.” So, we could get an estimate of the probability by playing the game lots of times; counting the proportion of times we win. This might still take a long time, but we could instead get a computer to simulate playing the game a large number of times, and then see how many times the computer wins. Using (computer generated) simulations to estimate probabilities (and other quantities) is known as the Monte Carlo method. We can use the Monte Carlo method to get approximate solutions to lots of problems that would be too difficult to solve otherwise. Programming the Monte Carlo method for the Canfield solitaire problem would be hard, but we can illustrate the method on a simpler example. 9.2 The birthday problem Suppose there are twenty people in a room. Ignore leap years, and suppose that each person is equally likely to have been born on any day of the year. What is the probability that at least two people in the room have the same birthday? We can actually solve this problem analytically (which we’ll do later), but it’s a good example for learning about R and the Monte Carlo method. The Monte Carlo method will involve getting R to simulate twenty random birthdays; determining whether any of the simulated birthdays are the same; repeating steps 1 and 2 lots of times, and counting the proportion of times we observe two or more of the twenty random birthdays to be the same. In the next section, we’ll look at how to use ‘for loops’ as a means of repeating a process multiple times. for loops are not strictly necessary for these sorts of problems, but they are easy to write and read; it can be easier to understand the link between the mathematical algorithm and its computer implementation.↩︎ Eckhardt, Roger (1987). Stan Ulam, John von Neumann, and the Monte Carlo method. Los Alamos Science (15): 131–137.↩︎ "],["loops.html", "Section 10 Loops 10.1 Pre-assigning 10.2 ‘looping’ by hand 10.3 for loops", " Section 10 Loops In this section, we will use the Monte Carlo method to solve the birthday problem, introducing one more programming concept: the ‘for loop’. 10.1 Pre-assigning We need to simulate lots of separate sets of 20 birthdays. To keep things simple and easy to visualise, we’ll first simulate five sets of 20 birthdays, then do more later. We will simulate one set of 20 birthdays at a time, and record the number of unique birthdays. It can be helpful to ‘pre-assign’ a vector, so that we’ve got somewhere convenient to store the results as they come in. We’ll make a vector called numberUnique, that initially just consists of five zeros. We can use the rep() command to replicate 0 five times: numberUnique &lt;- rep(0, times = 5) and to see what the result is: numberUnique ## [1] 0 0 0 0 0 The zeros will all be replaced as we work through the simulation, so the values in numberUnique aren’t important right now: what matters is that we have a vector with five places, ready to store the results. (An analogy would be that this is a bit like, having been told we’re going to be given five books, we first clear an empty space for five books on a bookshelf. We’ve then got somewhere ready to put the books as we get them.) 10.2 ‘looping’ by hand A slow and tedious way to do the five simulations would be as follows. We simulate the first set of 20 birthdays, count how many unique birthdays there are, and store the result in element 1 of numberUnique: birthdays &lt;- sample(x = 1:365, size = 20, replace = TRUE) numberUnique[1] &lt;- length(unique(birthdays)) so that the first element of numberUnique has been updated: numberUnique ## [1] 19 0 0 0 0 (We’ll have a quick look at birthdays, to see why the first element is 19) sort(birthdays) ## [1] 48 62 71 75 84 102 130 152 172 176 186 235 245 255 259 291 307 307 312 ## [20] 365 (There are 19 unique birthdays: two people had birthdays on day number 307.) Then we simulate the second set of 20 birthdays, count how many unique birthdays there are, and store the result in element 2 of numberUnique: birthdays &lt;- sample(x = 1:365, size = 20, replace = TRUE) numberUnique[2] &lt;- length(unique(birthdays)) Note that sample() produces a different result each time, so we’ll have different values in birthdays: sort(birthdays) ## [1] 54 65 76 80 126 126 150 152 180 197 203 246 288 300 303 304 315 316 320 ## [20] 357 Now the second element of numberUnique has been updated: numberUnique ## [1] 19 19 0 0 0 and we keep going… But to do lots of simulations, this would take ages! Exercise 10.1 In a script file, first pre-assign numberUnique to be a vector of 5 zeros. Then copy these two lines into your script, pasting them five times: birthdays &lt;- sample(x = 1:365, size = 20, replace = TRUE) numberUnique[1] &lt;- length(unique(birthdays)) Change the numbers in the square brackets [] as appropriate: your goal is to do five simulations, and replace the 5 zeros in numberUnique with the results from the five simulations. Run your script and look at the values in numberUnique, to see that your script has worked. 10.3 for loops A more convenient way to tell R to do the five (or many more) simulations is to use what we call a for loop: for(i in 1:5){ birthdays &lt;- sample(x = 1:365, size = 20, replace = TRUE) numberUnique[i] &lt;- length(unique(birthdays)) } This is the same (but more concise) as writing out the following: birthdays &lt;- sample(x = 1:365, size = 20, replace = TRUE) numberUnique[1] &lt;- length(unique(birthdays)) birthdays &lt;- sample(x = 1:365, size = 20, replace = TRUE) numberUnique[2] &lt;- length(unique(birthdays)) birthdays &lt;- sample(x = 1:365, size = 20, replace = TRUE) numberUnique[3] &lt;- length(unique(birthdays)) birthdays &lt;- sample(x = 1:365, size = 20, replace = TRUE) numberUnique[4] &lt;- length(unique(birthdays)) birthdays &lt;- sample(x = 1:365, size = 20, replace = TRUE) numberUnique[5] &lt;- length(unique(birthdays)) Comparing the two, we can see that in the for loop, the commands inside the brackets { } have been repeated five times, but with the value of i within [i] cycling through the integers 1, 2, 3, 4, 5. R will cycle i through these five values, because as the start of the for loop, we wrote i = 1:5, and 1:5 produces these five integers. The ‘looping’ variable i can also be within calculations. Here’s a simple example. This loop will do four ‘iterations’, so we will first pre-assign a vector with four zeros to store the results: results &lt;- rep(0, times = 4) Then this for loop: for(i in 1:4){ results[i] &lt;- i ^ (i + 1) } would be equivalent to writing out results[1] &lt;- 1 ^ (1 + 1) results[2] &lt;- 2 ^ (2 + 1) results[3] &lt;- 3 ^ (3 + 1) results[4] &lt;- 4 ^ (4 + 1) ::: {.exercise} Using for loops. Modify the birthday problem for loop shown above to do 10 simulations rather than 5. Make sure you ‘pre-assign’ numberUnique first, to be a vector of 10 zeros. Inspect the results in numberUnique, after you have run your loop. First, copy and paste these commands into a script file, then run them and inspect reciprocals to see the result reciprocals &lt;- rep(0, 3) reciprocals[1] &lt;- 1 / 1 reciprocals[2] &lt;- 1 / 2 reciprocals[3] &lt;- 1 / 3 Now write a for loop that produces the same result. All the calculations we’ve done using for loops can actually be done even more efficiently another way, but we won’t worry about this for now. for loops are really designed for problems when the results at one iteration will depend on results from previous iterations, as in the following example. Can you predict which famous sequence the following code would produce? Copy and paste the code into R to find out. results &lt;- rep(1, times = 10) for(i in 3:10){ results[i] &lt;- results[i-1] + results[i-2] } (Why did we use i in 3:10 and not i in 1:10?) ::: "],["computing-accurate-monte-carlo-estimates.html", "Section 11 Computing accurate Monte Carlo estimates 11.1 Using the mean() command 11.2 Improving the accuracy of the estimate", " Section 11 Computing accurate Monte Carlo estimates Returning to the result of our original for loop, we had numberUnique ## [1] 19 19 20 20 20 From this, we estimate the probability that at least two people have the same birthday, by counting the proportion of times there were fewer than 20 unique birthdays: sum(numberUnique &lt; 20) / 5 ## [1] 0.4 So our estimated probability is 0.4. Remember that, on its own, numberUnique &lt; 20 produces ## [1] TRUE TRUE FALSE FALSE FALSE so that sum(numberUnique &lt; 20) adds up the number of TRUEs (each TRUE is interpreted as a 1, and each FALSE is interpreted as a zero.) 11.1 Using the mean() command It’s slightly easier to use the mean() command instead of sum(), as it will add up the values and divide by the number of values there are (it will do the dividing by 5 for us). mean(numberUnique &lt; 20) ## [1] 0.4 11.2 Improving the accuracy of the estimate Roughly speaking, the more simulations we do, the better the estimate will be. Simulating 5 sets of 20 birthdays wasn’t enough, so let’s try a larger number: 100,000: numberUnique &lt;- rep(0, 100000) for(i in 1:100000){ birthdays &lt;- sample(x = 1:365, size = 20, replace = TRUE) numberUnique[i] &lt;- length(unique(birthdays)) } mean(numberUnique &lt; 20) ## [1] 0.40967 We can repeat this a few times to see if the answer changes much. The estimate looks fairly stable correct to two decimal places. If we needed to, we could do even more simulations (millions), though we’ll start noticing that the code takes longer to run. Exercise 11.1 Suppose there are, instead, 30 people in the room, and they are all born in a leap year. Assume each person is equally likely to have been born on any day of the year. Use the Monte Carlo method to estimate the probability that at least two people have birthdays on the same day; estimate the probability that two people only have birthdays on the same day. "],["an-analytical-solution.html", "Section 12 An analytical solution 12.1 Total number of possibilities 12.2 Number of possibilities where all birthdays are different", " Section 12 An analytical solution Returning to the case of 20 people in a non-leap year, we can compute the probability analytically via \\[ P(\\mbox{at least two birthdays the same}) = 1 - P(\\mbox{all 20 birthdays different}) \\] 12.1 Total number of possibilities To compute \\(P(\\mbox{all 20 birthdays different})\\), first count the total number of possibilities (regardless of whether any birthdays are the same or not): there are 365 possible days for person 1 for each possible day for person 1, there are 365 possible days for person 2… so there are \\(365 \\times 365\\) possibilities for persons 1 and 2 combined. Extending this argument, the total number of possibilities must be \\(365 \\times 365 \\times 365 \\times \\ldots \\times 365\\), i.e. \\(365^{20}\\). 12.2 Number of possibilities where all birthdays are different person 1 can have a birthday on any day; person 2 must have a birthday on a different day: there are 364 possibilities for person 2, and \\(365 \\times 364\\) possibilities for persons 1 and 2 combined; person 3 must have a birthday on different days to persons 1 and 2: there are 363 possibilities. Extending this argument, the total number of possibilities must be \\(365\\times 364 \\times 363 \\times \\ldots \\times 346\\). ::: {.exercise} Using the analytical solution. Compute the probability that at least two birthdays are the same use the : to create a sequence of integers use the prod() command to multiply the elements of a vector together Compare your answer with the Monte Carlo estimate. ::: "],["r-markdown.html", "Section 13 R Markdown 13.1 Making html and PDF documents 13.2 A five minute video tutorial 13.3 Code chunk options 13.4 Spell checking", " Section 13 R Markdown R Markdown (Allaire et al. 2020), (Xie, Allaire, and Grolemund 2018) is a system for producing reports. From a single R Markdown document, you can produce your report in a variety of formats including: PDF, Word document, web page (html), slides (including Powerpoint and Beamer). (Artwork by @allison_horst) The main idea is that your text and R code go in the same document. When you compile (or “knit”) your document, the R code is run, and the code input and output can be displayed in your report. This has several advantages. Your analyses will be more transparent and reproducible. If someone else (or even you at some point in the future) want to know, say, what calculations were done to produce a particular result in the report, the R Markdown document can be inspected to see what R code was used to get the result. You will save a lot of time if you need to include plots in your report: you write the code to make your plot, and then R Markdown inserts the plot in your report automatically. If changes are made to the data, or if you make some change early on in your analysis, you can just recompile your report, and the code will be re-run with the new data, and all the new results will appear in the re-compiled report. (You may, of course, need to change your text commentary) 13.1 Making html and PDF documents You can always produce a report in html format. If you want to make PDF documents, you will need LaTeX installed on your computer. If you don’t have LaTeX installed, a suggestion is to install a ‘lightweight’ version TinyTeX, which you can do within R: install.packages(&quot;tinytex&quot;) tinytex::install_tinytex() Similarly, if you want to make Word documents, you will need Word installed. 13.2 A five minute video tutorial This video illustrates the basics of how to work with an R Markdown document. Exercise 13.1 Put your solution to the birthday problem exercise inside an R Markdown document. Include some plain text that briefly explains what probability you are estimating. Produce a histogram of the number of unique birthdays by including the command hist(numberUnique) Knit your document to html. 13.3 Code chunk options This video illustrates how to use code chunk options to change the appearance of a document (One useful option that I didn’t mention in the video is include = FALSE. This will run the code, but will not display the input or any output, including messages and warnings.) 13.3.1 Code chunk options for figures For reference, here’s an example code chunk with the options you would typically need to use when making a plot. (If you want to run this code, you will need to install the package ggplot2.) ```{r, fig.align = &#39;center&#39;, fig.cap = &quot;My figure caption&quot;, fig.height = 3, fig.width = 3} ggplot2::ggplot(mtcars, ggplot2::aes(x = wt, y = mpg)) + ggplot2::geom_point() ``` Some trial and error may be needed to find values for fig.height and fig.width that give the figure size you want. If importing a figure rather than generating it in R, you may find the option out.width = \"60%\" easier to work with than fig.height and fig.width. Again, you may need trial and error to decide on the best percentage value. 13.4 Spell checking RStudio has a spell checker. To use it, click the green tick (with ABC above) button, in the document window. If you wish, you can go to Tools &gt; Global Options… &gt; Spelling and change the Main dictionary language to English (United Kingdom). Using the spell checker will not identify all possible errors. Proofread your work carefully! Exercise 13.2 Use suitable code chunk options to change the appearance of your R Markdown document from the previous Exercise. Make sure no R code appears in your html/pdf document Include a figure caption, centre-align your figure, and manually set an appropriate figure size. References "],["rstudio-projects.html", "Section 14 RStudio Projects 14.1 File paths and working directories 14.2 Creating a new project 14.3 Opening an existing project 14.4 Using your project folder", " Section 14 RStudio Projects RStudio Projects can be helpful for organising your files. If you are working on more than one project using R, RStudio Projects make it easier to keep your work for each project separate, and to find the files you need each time you start up R. 14.1 File paths and working directories We’ll discuss importing data in a later section, but it’s helpful at this point to understand the idea of a working directory in relation to your data files (RStudio Projects make the whole process easier to manage.) Suppose you have a data file myData.csv you want to import. How will R find this file? R will have a current working directory, which you can see with the command getwd() If your file myData.csv is in this folder, you can import it with the command readr::read_csv(&quot;myData.csv&quot;) R will look in the current working directory, and find your file. If your data files is in a different folder, three options are Specify the full file path to your data file, e.g. something like readr::read_csv(&quot;/Users/Jeremy/Documents/MAS113/myData.csv&quot;) Change your working directory to the folder containing the data file, using Session &gt; Set Working Directory &gt; Choose Directory… from the RStudio menu bar. If possible, specify the file path relative to your current working directory, e.g. if your current working directory is /Users/Jeremy/Documents, and the data file is in a sub-folder of Documents called MAS113, you could use the command readr::read_csv(&quot;MAS113/myData.csv&quot;) Option 3 is recommended, as it make things a bit easier if you want to transfer your work between different computers, or share code and data with others. But this all gets messy if you’re working on different projects, and you want to keep your files nicely organised on your computer. As we’ll see, RStudio projects become useful here. 14.1.1 Working directories for R Markdown documents When we run a code chunk inside an R Markdown document, the working directory is set to be directory containing the document (check this by running the command getwd() inside a code chunk.) If you are using an RStudio project, you may wish your data and R Markdown documents to be in different folders, e.g., if the project directory is myProject, you may have folders myProject/data myProject/reports If your R Markdown document is in the folder myProject/reports, and you want to import a file myData.csv from myProject/data, specify the (relative) file path in your R Markdown document as myData &lt;- read_csv(&quot;../data/myData.csv&quot;) 14.2 Creating a new project You can create different types of projects, but for a ‘basic’ one, go to File &gt; New Project…&gt; New Directory &gt; New Project &gt; Browse then choose a folder on your computer in which you wish to locate your project, then choose a project name and click create project. This will create a sub-folder, within your selected folder. The sub-folder will have your project name. The sub-folder will contain a .Rproj file, which identifies the project. From a file explorer, you should be able to click on this and launch RStudio with the project open. You can also use the Project menu of the right hand side of the RStudio window. 14.3 Opening an existing project You can either go to File &gt; Open Project… and find your .Rproj file, or you can use the Project menu at the top right. When you open a project, RStudio will set the working directory to that project folder, and open any files you were working on the last time you worked on that project. The Files tab in RStudio will display your project folder, and there are various tools in this tab for working with your files. Depending on your settings, RStudio may open your most recent project, if you were working on it the last time you used RStudio. You can close a project using the Project menu. 14.4 Using your project folder In your new project folder, you should keep all files associated with that project. You might create further sub-folders within your project folder. For example, it’s a good idea to have a ‘data’ folder, containing any data sets used in your project. You might have another sub-folder for R scripts. These will all be sub-folders of the project working directory, which makes them a little easier to work with. "],["more-on-r-markdown.html", "Section 15 More on R Markdown 15.1 Tables 15.2 Caching results for slow-running code 15.3 R Markdown for LaTeX users 15.4 The YAML header", " Section 15 More on R Markdown 15.1 Tables There are several options for producing tables in R Markdown. 15.1.1 Using Markdown Here’s an example of making a table with the Markdown syntax. Note the use of : for specifying text alignment. | column 1 | column 2 | column 3 | |:----------|:---------:|----------:| | this text | this text | this text | | is left | is centre | is right | | aligned | aligned | aligned | This is rendered as follows. column 1 column 2 column 3 this text this text this text is left is centre is right aligned aligned aligned Online tools are available for generating Markdown syntax, for example https://www.tablesgenerator.com/markdown_tables. 15.1.2 Using knitr::kable() The knitr package (Xie 2020), (Xie 2014), (Xie 2015) has the kable() function which can produce a table from a data frame. Here’s an example. knitr::kable(head(mtcars)) which is rendered (in html) as follows: mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 15.2 Caching results for slow-running code If some of your code takes a long time to run, it is preferable not to re-run it every time you edit your R Markdown document and want to re-compile it. It you use the code chunk option cache = TRUE, R will store (‘cache’) the results, and will only re-run the code chunk if it detects that something has changed. Be careful if you use caching. For example, if you import a file and cache the results, R will not detect if the file contents change. When you knit your final version of your document, switch off all caching. 15.3 R Markdown for LaTeX users The Markdown language is broadly the same as LaTeX for typesetting equations/maths notation, and so you can use LaTeX as normal for typesetting maths. You can use any other LaTeX commands throughout your document. When producing pdf output, R Markdown will actually generate an intermediate .tex file, which is then compiled to pdf. However, these commands will be ignored if you knit to html or other formats. Similarly, you can include html commands in your document; these will only work if you knit to html. Try to keep to Markdown commands as far as possible. This will give you the most flexibility regarding your choice of output format (and you may wish to switch your output format in the future.) For example, putting this in your document: \\section{Introduction} will only produce the desired section heading if you knit to pdf, but using this: # Introduction will give the desired section heading for any output format you produce. 15.4 The YAML header The first part of an R Markdown document, the ‘header’ is used to specify information such as author and title, and can include extra commands to change the appearance of the document. These are commands are specified using another language called YAML. Here’s an example of a YAML header, with a few extra commands specified that you might find helpful. --- title: &quot;My Report Title&quot; author: &quot;Jeremy Oakley&quot; date: &quot;2022-09-15&quot; output: pdf_document: number_sections: true html_document: number_sections: true fontsize: 11pt urlcolor: blue header-includes: - \\usepackage{bm} --- Indenting of particular lines does matter in YAML. Keep this is mind when copying YAML examples. The command Sys.Date() is an R command which will insert today’s date (year-month-day format). The commands fontsize and urlcolor affect pdf output only. The final command header-includes: - \\usepackage{bm} can be used to add commands (e.g. \\usepackage{bm}) to the preamble in the LaTeX document for pdf output. References "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
